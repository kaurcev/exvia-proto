<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Exvia SDK Test (IndexedDB)</title>
  <style>
    *{ box-sizing: border-box;}
    body { font-family: sans-serif; max-width: 1200px; margin: 20px auto; padding: 0 20px; }
    pre { background: #f4f4f4; padding: 10px; border-radius: 5px; overflow: auto; max-height: 200px; }
    button { margin: 5px; padding: 5px 10px; }
    input, textarea { width: 100%; margin-bottom: 10px; padding: 5px; box-sizing: border-box; }
    .flex { display: flex; gap: 20px; flex-wrap: wrap; }
    .flex > div { flex: 1; min-width: 300px; }
    .key-box { background: #eee; padding: 10px; border-radius: 5px; word-break: break-all; font-family: monospace; }
    .log-area { background: #000; color: #0f0; padding: 10px; border-radius: 5px; height: 300px; overflow-y: scroll; font-family: monospace; }
    .log-entry { margin: 2px 0; }
    .status { font-weight: bold; color: #00f; }
    .error { color: #f00; }
    .success { color: #0a0; }
  </style>
</head>
<body>
  <div class="flex">
    <div>
      <h2>Identity</h2>
      <p><strong>Public key (hex):</strong></p>
      <div id="myKey" class="key-box"></div>
      <p><strong>Nick:</strong> <input type="text" id="nick" placeholder="Your nick" /></p>
      <button id="saveNick">Save Nick</button>
      <button id="exportKeys">Export Keys (base64)</button>
      <button id="importKeys">Import Keys</button>
      <div id="importArea" style="display:none; margin-top:10px;">
        <textarea id="importData" rows="4" placeholder='Paste {"publicKey":"...","privateKey":"..."} here'></textarea>
        <button id="doImport">Apply Import</button>
      </div>
    </div>

    <div>
      <h2>Servers</h2>
      <input type="text" id="serverAddress" placeholder="ws://localhost:8080" size="40" />
      <button id="addServer">Add Server</button>
      <button id="requestServers">Request Servers List</button>
      <ul id="serverList"></ul>
      <button id="connect" disabled>Connect to selected</button>
      <button id="disconnect" disabled>Disconnect</button>
      <span id="connectionStatus" class="status">Not connected</span>
    </div>

    <div>
      <h2>Send Data</h2>
      <input type="text" id="targetKey" placeholder="Target public key (hex)" size="64" />
      <select id="dataType">
        <option value="text">Plain text</option>
        <option value="json">JSON</option>
        <option value="file">File</option>
      </select>
      <div id="textInput">
        <textarea id="textContent" rows="5" placeholder="Message text"></textarea>
      </div>
      <div id="jsonInput" style="display:none;">
        <textarea id="jsonContent" rows="5" placeholder='{"hello":"world"}'></textarea>
      </div>
      <div id="fileInput" style="display:none;">
        <input type="file" id="fileContent" />
      </div>
      <button id="sendBtn">Send</button>
    </div>
  </div>

  <hr/>
  <h2>Log</h2>
  <div id="log" class="log-area"></div>

  <script type="module">
    import { Client, IndexedDBStorage, ContentType } from './sdk/index.ts';

    // DOM elements
    const logDiv = document.getElementById('log');
    const myKeySpan = document.getElementById('myKey');
    const nickInput = document.getElementById('nick');
    const saveNickBtn = document.getElementById('saveNick');
    const exportKeysBtn = document.getElementById('exportKeys');
    const importKeysBtn = document.getElementById('importKeys');
    const importArea = document.getElementById('importArea');
    const importData = document.getElementById('importData');
    const doImportBtn = document.getElementById('doImport');
    const serverAddressInput = document.getElementById('serverAddress');
    const addServerBtn = document.getElementById('addServer');
    const requestServersBtn = document.getElementById('requestServers');
    const serverList = document.getElementById('serverList');
    const connectBtn = document.getElementById('connect');
    const disconnectBtn = document.getElementById('disconnect');
    const connectionStatus = document.getElementById('connectionStatus');
    const targetKeyInput = document.getElementById('targetKey');
    const dataTypeSelect = document.getElementById('dataType');
    const textInputDiv = document.getElementById('textInput');
    const jsonInputDiv = document.getElementById('jsonInput');
    const fileInputDiv = document.getElementById('fileInput');
    const textContent = document.getElementById('textContent');
    const jsonContent = document.getElementById('jsonContent');
    const fileContent = document.getElementById('fileContent');
    const sendBtn = document.getElementById('sendBtn');

    // Helper: Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð·Ð°Ð¿Ð¸ÑÑŒ Ð² Ð»Ð¾Ð³
    function addLog(msg, className = '') {
      const entry = document.createElement('div');
      entry.className = 'log-entry ' + className;
      entry.textContent = new Date().toLocaleTimeString() + ': ' + msg;
      logDiv.appendChild(entry);
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    // Ð˜Ð½Ð¸Ñ†Ð¸Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ñ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð° Ñ IndexedDB
    const storage = new IndexedDBStorage();
    const client = new Client(storage);

    // Ð—Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÐ¼ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ð¸Ð· Ñ…Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ð°
    await client.init();
    
    // ÐžÑ‚Ð¾Ð±Ñ€Ð°Ð¶Ð°ÐµÐ¼ ÐºÐ»ÑŽÑ‡
    myKeySpan.textContent = client.getPublicKeyHex();
    nickInput.value = client.getNick();

    // Ð—Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÐ¼ ÑÐ¿Ð¸ÑÐ¾Ðº ÑÐµÑ€Ð²ÐµÑ€Ð¾Ð² Ð¸ Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶Ð°ÐµÐ¼
    async function refreshServerList() {
      const servers = await client.getServers();
      const selected = await client.getSelectedServer();
      serverList.innerHTML = '';
      servers.forEach(addr => {
        const li = document.createElement('li');
        const radio = document.createElement('input');
        radio.type = 'radio';
        radio.name = 'server';
        radio.value = addr;
        radio.checked = (addr === selected);
        radio.addEventListener('change', async () => {
          await client.selectServer(addr);
          updateConnectButton();
        });
        li.appendChild(radio);
        li.appendChild(document.createTextNode(' ' + addr));
        
        const removeBtn = document.createElement('button');
        removeBtn.textContent = 'Remove';
        removeBtn.style.marginLeft = '10px';
        removeBtn.addEventListener('click', async () => {
          await client.removeServer(addr);
          refreshServerList();
          updateConnectButton();
        });
        li.appendChild(removeBtn);
        
        serverList.appendChild(li);
      });
      updateConnectButton();
    }
    refreshServerList();

    async function updateConnectButton() {
      const selected = await client.getSelectedServer();
      connectBtn.disabled = !selected;
    }

    // ÐŸÐµÑ€ÐµÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð»ÐµÐ¹ Ð²Ð²Ð¾Ð´Ð°
    dataTypeSelect.addEventListener('change', () => {
      textInputDiv.style.display = 'none';
      jsonInputDiv.style.display = 'none';
      fileInputDiv.style.display = 'none';
      if (dataTypeSelect.value === 'text') textInputDiv.style.display = 'block';
      else if (dataTypeSelect.value === 'json') jsonInputDiv.style.display = 'block';
      else if (dataTypeSelect.value === 'file') fileInputDiv.style.display = 'block';
    });

    // Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ð½Ð¸Ðº
    saveNickBtn.onclick = async () => {
      const nick = nickInput.value.trim() || 'Anonymous';
      await client.setNick(nick);
      addLog(`Nick saved: ${nick}`, 'success');
    };

    // Ð­ÐºÑÐ¿Ð¾Ñ€Ñ‚ ÐºÐ»ÑŽÑ‡ÐµÐ¹
    exportKeysBtn.onclick = () => {
      try {
        const { publicKey, privateKey } = client.exportKeys();
        const exportStr = JSON.stringify({ publicKey, privateKey }, null, 2);
        navigator.clipboard?.writeText(exportStr).catch(() => {});
        addLog(`Keys exported (base64). Copied to clipboard?`, 'success');
        // ÐŸÐ¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ð² Ð¾Ñ‚Ð´ÐµÐ»ÑŒÐ½Ð¾Ð¼ Ð¾ÐºÐ½Ðµ Ð´Ð»Ñ ÑƒÐ´Ð¾Ð±ÑÑ‚Ð²Ð°
        alert('Keys (base64):\n\n' + exportStr);
      } catch (e) {
        addLog(`Export error: ${e.message}`, 'error');
      }
    };

    // ÐŸÐ¾ÐºÐ°Ð·Ð°Ñ‚ÑŒ Ð¾Ð±Ð»Ð°ÑÑ‚ÑŒ Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ð°
    importKeysBtn.onclick = () => {
      importArea.style.display = importArea.style.display === 'none' ? 'block' : 'none';
    };

    // Ð˜Ð¼Ð¿Ð¾Ñ€Ñ‚ ÐºÐ»ÑŽÑ‡ÐµÐ¹
    doImportBtn.onclick = async () => {
      try {
        const data = JSON.parse(importData.value);
        if (!data.publicKey || !data.privateKey) throw new Error('Missing publicKey or privateKey');
        await client.importKeys(data.publicKey, data.privateKey);
        addLog('Keys imported successfully', 'success');
        myKeySpan.textContent = client.getPublicKeyHex();
        importArea.style.display = 'none';
        importData.value = '';
      } catch (e) {
        addLog(`Import error: ${e.message}`, 'error');
      }
    };

    // Ð”Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ ÑÐµÑ€Ð²ÐµÑ€
    addServerBtn.onclick = async () => {
      const addr = serverAddressInput.value.trim();
      if (!addr) return;
      await client.addServer(addr);
      serverAddressInput.value = '';
      refreshServerList();
      addLog(`Server added: ${addr}`, 'success');
    };

    // Ð—Ð°Ð¿Ñ€Ð¾ÑÐ¸Ñ‚ÑŒ ÑÐ¿Ð¸ÑÐ¾Ðº ÑÐµÑ€Ð²ÐµÑ€Ð¾Ð² Ñƒ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ³Ð¾ ÑÐµÑ€Ð²ÐµÑ€Ð°
    requestServersBtn.onclick = async () => {
      try {
        if (!client.isConnected()) {
          addLog('Not connected', 'error');
          return;
        }
        await client.requestServerList();
        addLog('Requested servers list', 'info');
      } catch (e) {
        addLog(`Request failed: ${e.message}`, 'error');
      }
    };

    // ÐŸÐ¾Ð´ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ
    connectBtn.onclick = async () => {
      const selected = await client.getSelectedServer();
      if (!selected) return;
      try {
        addLog(`Connecting to ${selected}...`, 'info');
        await client.connect(selected);
        connectionStatus.textContent = `Connected to ${selected}`;
        connectionStatus.className = 'status success';
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
      } catch (e) {
        addLog(`âŒ Connection failed: ${e.message}`, 'error');
        connectionStatus.textContent = 'Connection failed';
        connectionStatus.className = 'status error';
      }
    };

    // ÐžÑ‚ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ
    disconnectBtn.onclick = () => {
      client.disconnect();
      connectionStatus.textContent = 'Disconnected';
      connectionStatus.className = 'status';
      connectBtn.disabled = false;
      disconnectBtn.disabled = true;
    };

    // Ð¡Ð¾Ð±Ñ‹Ñ‚Ð¸Ñ ÐºÐ»Ð¸ÐµÐ½Ñ‚Ð°
    client.on('connected', (url) => {
      addLog(`Connected to ${url}`, 'success');
    });

    client.on('disconnected', () => {
      addLog('Disconnected', 'info');
      connectionStatus.textContent = 'Disconnected';
      connectionStatus.className = 'status';
      connectBtn.disabled = false;
      disconnectBtn.disabled = true;
    });

    client.on('serversDiscovered', (addresses) => {
      addLog(`Discovered new servers: ${addresses.join(', ')}`, 'info');
      refreshServerList();
    });

    client.on('serversChanged', () => {
      refreshServerList();
    });

    client.on('error', (err) => {
      addLog(`Error: ${err.message}`, 'error');
    });

    // ÐžÐ±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ° Ð²Ñ…Ð¾Ð´ÑÑ‰Ð¸Ñ… ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ð¹
    client.on('message', (from, content, contentType, parsed) => {
      const fromHex = Array.from(from).map(b => b.toString(16).padStart(2,'0')).join('').slice(0,8);
      
      let display = '';
      if (contentType === ContentType.TEXT) {
        display = `ðŸ“© From ${fromHex} (text): ${parsed}`;
      } else if (contentType === ContentType.JSON) {
        display = `ðŸ“© From ${fromHex} (JSON): ${JSON.stringify(parsed)}`;
      } else if (contentType === ContentType.FILE) {
        display = `ðŸ“© From ${fromHex} (file): ${parsed.name} (${parsed.data.length} bytes)`;
      } else {
        const hex = Array.from(content.slice(0, 16)).map(b => b.toString(16).padStart(2,'0')).join(' ');
        display = `ðŸ“© From ${fromHex} (raw, ${content.length} bytes): ${hex}${content.length > 16 ? '...' : ''}`;
      }
      addLog(display, 'message');
    });

    // ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ°
    sendBtn.onclick = async () => {
      const targetHex = targetKeyInput.value.trim().replace(/\s+/g, '');
      if (!targetHex) {
        addLog('Target key required', 'error');
        return;
      }
      if (!/^[0-9a-fA-F]{64}$/.test(targetHex)) {
        addLog('Target key must be 64 hex characters', 'error');
        return;
      }

      const type = dataTypeSelect.value;

      try {
        if (type === 'text') {
          const text = textContent.value.trim();
          if (!text) { addLog('Text required', 'error'); return; }
          client.sendText(targetHex, text);
          addLog(`ðŸ“¤ Sent text to ${targetHex.slice(0,8)}: ${text}`, 'sent');
          textContent.value = '';
        } 
        else if (type === 'json') {
          const jsonStr = jsonContent.value.trim();
          if (!jsonStr) { addLog('JSON required', 'error'); return; }
          const obj = JSON.parse(jsonStr); // validate
          client.sendJSON(targetHex, obj);
          addLog(`ðŸ“¤ Sent JSON to ${targetHex.slice(0,8)}: ${jsonStr}`, 'sent');
          jsonContent.value = '';
        } 
        else if (type === 'file') {
          const file = fileContent.files?.[0];
          if (!file) { addLog('File required', 'error'); return; }
          await client.sendFileAsync(targetHex, file);
          addLog(`ðŸ“¤ Sent file to ${targetHex.slice(0,8)}: ${file.name} (${file.size} bytes)`, 'sent');
          fileContent.value = '';
        }
      } catch (e) {
        addLog(`Error: ${e.message}`, 'error');
      }
    };

    if (client.isConnected()) {
      connectionStatus.textContent = 'Connected';
      connectionStatus.className = 'status success';
      connectBtn.disabled = true;
      disconnectBtn.disabled = false;
    }
  </script>
</body>
</html>